
	include "includes/nesdefs.dasm"

;;;;; VARIABLES

	include "variables.dasm"




;;;;; NES CARTRIDGE HEADER

	NES_HEADER 0,2,1,NES_MIRR_HORIZ ; mapper 0, 2 PRGs, 1 CHR

;;;;; START OF CODE

Start:	subroutine
; wait for PPU warmup; clear CPU RAM
	NES_INIT	; set up stack pointer, turn off PPU
    jsr WaitSync	; wait for VSYNC
    jsr WaitSync	; wait for VSYNC
    jsr ClearRAM	; clear RAM
    jsr WaitSync	; wait for VSYNC (and PPU warmup)

; set palette and nametable VRAM
	jsr SetPalette	; set palette colors
	;jsr FillVRAM		;set PPU RAM
	jsr HelloVRAM	; print message in name table

    jsr WaitSync		;wait for VSYNC (and PPU warmup)
    ;jsr InitSprites
	;jsr Test_Sprites
    jsr Init_Sprites
    jsr Init_Vars

; reset PPU address and scroll registers
    lda #0
    sta PPU_ADDR
    sta PPU_ADDR	; PPU addr = $0000
    sta PPU_SCROLL
    sta PPU_SCROLL  ; PPU scroll = $0000

; activate PPU graphics
    ;lda #MASK_BG
    lda #MASK_BG|MASK_SPR
    sta PPU_MASK 	; enable rendering
    lda #CTRL_NMI
    sta PPU_CTRL	; enable NMI
.endless
	jmp .endless	; endless loop



; set palette colors
SetPalette: subroutine
; set PPU address to palette start
	PPU_SETADDR $3f00
    ldy #0
.loop:
	lda Palette,y	; lookup byte in ROM
	sta PPU_DATA	; store byte to PPU data
    iny		; Y = Y + 1
    cpy #32		; is Y equal to 32?
	bne .loop	; not yet, loop
    rts		; return to caller

; fill video RAM with "Hello World" msg
HelloVRAM: subroutine
; set PPU address to name table A (row 1, col 1)
	PPU_SETADDR $2021
	ldy #0		; set Y counter to 0
.loop:
	lda HelloMsg,y	; get next character
    beq .end	; is 0? exit loop
	sta PPU_DATA	; store+advance PPU
    iny		; next character
	bne .loop	; loop
.end
    rts		; return to caller

; fill video RAM
FillVRAM: subroutine
	PPU_SETADDR $2000
	ldy #$10	; Y = 16
    ldx #0
.loop:
	stx PPU_DATA	; X -> PPU data port
	inx		; X = X + 1
	bne .loop	; repeat until 256 bytes
	dey		; Y = Y - 1
	bne .loop	; repeat until Y is 0
    rts		; return to caller
    

    
;;;;; COMMON SUBROUTINES

	include "includes/nesppu.dasm"
	
    include "includes/common-routines.dasm"

    include "init/init-sprites.dasm"
    include "init/init-vars.dasm"
    
    include "game-logic/game-logic.dasm"
    include "game-logic/read-input.dasm"
    include "game-logic/move-p2.dasm"
    include "game-logic/move-ball.dasm"
    include "game-logic/update-score.dasm"
    include "game-logic/update-sprites.dasm"




;;;;; INTERRUPT HANDLERS

NMIHandler: subroutine
	SAVE_REGS
    
    ; code here

	; load sprites
	lda #$02	; page 2 ($0200)
    sta PPU_OAM_DMA	; start DMA transfer

    jsr Game_Logic

	RESTORE_REGS
	rti






;;;;; CONSTANT DATA

; ASCII message to display on screen
HelloMsg:
	.byte "Pong NES Test !!! v.0.0.19", 0
    ;.byte 0		; zero terminator

Palette:
	hex 1f		;screen color
	hex 01112100	;background 0
    hex 02122200	;background 1
    hex 02112100	;background 2
    hex 01122200	;background 3
    hex 19293900	;sprite 0
    hex 1a2a3a00	;sprite 1
    hex 1b2b3b00	;sprite 2
    hex 1c2c3c	;sprite 3

OAM_Data_Init:
	; --- Ball
    .byte 	0	; Y
    .byte	25	; tile #
    .byte	0	; attributes
    .byte	0	; X

	; --- P1
    .byte 	0	; Y
    .byte	133	; tile #
    .byte	0	; attributes
    .byte	0   ; X
    
    ;	  Y, tile #, attrib,	X
    .byte	0, 	133, 	0, 	0

	; --- P2
    ;	  Y, tile #, attrib,	X
    .byte	0, 	133, 	3, 	0
    .byte	0, 	133, 	0, 	0
;OAM_Data_Init_size equ $ - OAM_Data_Init

Ball_OAM_Addr           equ 0 * 4
P1_Spr_1_OAM_Addr       equ 1 * 4
P1_Spr_2_OAM_Addr       equ 2 * 4
P2_Spr_1_OAM_Addr       equ 3 * 4
P2_Spr_2_OAM_Addr       equ 4 * 4

;;;;; CPU VECTORS

	NES_VECTORS

;;;;; TILE SETS

	org $10000
    incbin "jroatch.chr"
    incbin "jroatch.chr"
