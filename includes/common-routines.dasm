; Inputs:
;   X: address of object 1 (x, y, width, height)
;   Y: address of object 2 (x, y, width, height)
; Output: Carry reset if collision
Check_Collision: subroutine
	
    ; --------- Check X axis collision
    lda 0,Y                     ; A = x2
    sec		                    ; set carry
    sbc 0,X                     ; calculate x2 - x1
    bcc .x1Larger               ; jump if carry NOT set (x1 is larger)

    ; --- x1 is smaller or equal

    ; sec		                    ; set carry
    ; sbc 2,X                     ; compare with width 1

    cmp 2,X                     ; compare A with width 1

    bcs .noCollision            ; jump if carry set (no collision)

    ; Collision

    ; rts
    jmp .check_Y

.x1Larger:

    lda 0,X                     ; A = x1
    sec		                    ; set carry
    sbc 0,Y                     ; calculate x1 - x2

    ; sec		                    ; set carry
    ; sbc 2,Y                     ; compare with width 2
    
    cmp 2,Y                     ; compare A with width 2

    bcs .noCollision            ; jump if carry set (no collision)

    ; Collision

; .eternalLoop:    
;     jmp .eternalLoop ; debug

    ;rts                         ; return with carry NOT set (Collision)




.check_Y:
    ; --------- Check Y axis collision
    lda 1,Y                     ; A = y2
    sec		                    ; set carry
    sbc 1,X                     ; calculate y2 - y1
    bcc .y1Larger               ; jump if carry NOT set (y1 is larger)

    ; --- y1 is smaller or equal

    ; sec		                    ; set carry
    ; sbc 3,X                     ; compare with height 1

    cmp 3,X                     ; compare A with height 1

    bcs .noCollision            ; jump if carry set (no collision)

    ; Collision

    rts                         ; return with carry NOT set (Collision)

.y1Larger:

    lda 1,X                     ; A = y1
    sec		                    ; set carry
    sbc 1,Y                     ; calculate y1 - y2

    ; sec		                    ; set carry
    ; sbc 3,Y                     ; compare with height 2
    
    cmp 3,Y                     ; compare A with height 2

    bcs .noCollision            ; jump if carry set (no collision)

    ; Collision

; .eternalLoop:    
;     jmp .eternalLoop ; debug

    rts                         ; return with carry NOT set (Collision)




.noCollision:
    rts













    ; cmp 0,X		; compare A with Obj_1.X
    ; cmp 1,X		; compare A with Obj_1.Y
    
    ; cmp 0,Y		; compare A with Obj_2.X
    ; cmp 1,Y		; compare A with Obj_2.Y
    
; comparisons: CMP, CPX, CPY

;Relation	Z	C	N
;register < operand	0	0	sign-bit of result
;register = operand	1	1	0
;register > operand	0	1	sign-bit of result
;Meaning, we may dertermine the derivative relation "greater than or equal" (gte) by
;checking just the carry flag (using instruction BCS):

;Relation	Z	C	N
;register â‰¥ operand	x	1	sign-bit of result
